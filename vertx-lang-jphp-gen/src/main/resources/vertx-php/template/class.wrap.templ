@code{
	import java.util.TreeSet;
	import java.util.HashMap;

	var typeConverterMap = new HashMap();
	typeConverterMap["String"] = "STRING";
	typeConverterMap["byte"] = "BYTE";
	typeConverterMap["Byte"] = "BYTE";
	typeConverterMap["char"] = "CHARACTER";
	typeConverterMap["Character"] = "CHARACTER";
	typeConverterMap["short"] = "SHORT";
	typeConverterMap["Short"] = "SHORT";
	typeConverterMap["int"] = "INTEGER";
	typeConverterMap["Integer"] = "INTEGER";
	typeConverterMap["long"] = "LONG";
	typeConverterMap["Long"] = "LONG";
	typeConverterMap["double"] = "DOUBLE";
	typeConverterMap["Double"] = "DOUBLE";
	typeConverterMap["float"] = "FLOAT";
	typeConverterMap["Float"] = "FLOAT";
	typeConverterMap["boolean"] = "BOOLEAN";
	typeConverterMap["Boolean"] = "BOOLEAN";
	typeConverterMap["JsonObject"] = "JSON_OBJECT";
	typeConverterMap["JsonArray"] = "JSON_ARRAY";
	typeConverterMap["Throwable"] = "THROWABLE";
	typeConverterMap["Void"] = "VOID";

	def getTypeConverter(typeInfo){
		var typeKind = typeInfo.kind;
		if(typeKind.basic || typeKind.json || typeKind == CLASS_THROWABLE || typeKind == CLASS_VOID) {
			return "TypeConverter." + typeConverterMap[typeKind == CLASS_PRIMITIVE ? typeInfo.name : typeInfo.raw.simpleName];
		} else if(typeKind == CLASS_ENUM){
			return "EnumConverter.create(" + typeInfo.raw.simpleName + ".class)";
		} else if(typeKind == CLASS_DATA_OBJECT){
			return "DataObjectConverter.create(" + typeInfo.raw.packageName + "." + typeInfo.raw.simpleName + ".class, " + typeInfo.raw.packageName + "." + typeInfo.raw.simpleName + "::new, " + typeInfo.raw.simpleName + "::new)";
		} else if(typeKind == CLASS_LIST || typeKind == CLASS_SET || typeKind == CLASS_MAP) {
			var containerType = null;
			if(typeKind != CLASS_MAP){
				containerType = typeInfo.args.get(0);
			} else {
				containerType = typeInfo.args.get(1);
			}
			return "ContainerConverter.create" + typeInfo.raw.simpleName + "Converter(" + getTypeConverter(containerType) + ")";
		} else if(typeKind == CLASS_API) {
			var args = typeInfo.isParameterized ? typeInfo.args : [];
			var returnInfo = "VertxGenVariable0Converter.<";
			var typeParamInfo = "";
			var first = true;
			foreach(arg : args) {
				if(!first) {
					typeParamInfo += ", ";
				} else {
					first = false;
				}
				if(arg.isVariable) {
					if(arg.param.isClass) {
						typeParamInfo += arg.name;
					} else  {
						typeParamInfo += "Object";
					}
				} else {
					var argKind = arg.kind;
					if(argKind == CLASS_API || argKind == CLASS_DATA_OBJECT) {
						typeParamInfo += arg.raw.packageName + "." + arg.raw.simpleName;
					} else {
						typeParamInfo += arg.raw.simpleName;
					}
				}
			}
			var typeParamInfo2 = (typeParamInfo == "") ? "" : ("<" + typeParamInfo + ">");
			returnInfo += typeInfo.raw.packageName + "." + typeInfo.raw.simpleName + typeParamInfo2 + ", " + typeInfo.raw.simpleName + typeParamInfo2;
			returnInfo += (typeParamInfo == "" ? "" : ", ");
			returnInfo += typeParamInfo;
			returnInfo += ">create" + args.size() + "(" + typeInfo.raw.simpleName + ".class, " + typeInfo.raw.simpleName + "::__create";
			for(arg : args) {
				returnInfo += ", " + getTypeConverter(arg);
			}
			return returnInfo + ")";
		} else if(typeInfo.isVariable && typeInfo.param.isClass){
			return getConverterMethodName("get", typeInfo.name) + "()";
		} else {
			return "TypeConverter.UNKNOWN_TYPE";
		}
	}

	var packageName = type.translatePackageName("jphp");
	var importClassSet = new TreeSet();
	importClassSet.add("php.runtime.annotation.Reflection.Name");
	importClassSet.add("php.runtime.annotation.Reflection.Namespace");
	importClassSet.add("php.runtime.annotation.Reflection.Signature");
	importClassSet.add("php.runtime.env.Environment");
	if(typeParams.size() > 0) {
		importClassSet.add("io.vertx.lang.jphp.converter.TypeConverter");
	}

	def addImport(typeInfo, isParameterized, isParam){
		if(typeInfo.isVariable) {
			if(isParameterized) {
				importClassSet.add("io.vertx.lang.jphp.converter.TypeConverter");
			}
			return;
		}
		var typeKind = typeInfo.kind;
		if(typeKind == CLASS_API) {
			if(typeInfo.raw.packageName != ifacePackageName) {
				importClassSet.add(typeInfo.raw.translatePackageName("jphp") + "." + typeInfo.raw.simpleName);
			}
		} else if(typeKind == CLASS_DATA_OBJECT) {
			if(typeInfo.raw.packageName != ifacePackageName) {
				importClassSet.add(typeInfo.raw.translatePackageName("jphp") + "." + typeInfo.raw.simpleName);
			}
		} else if(typeKind == CLASS_JSON_OBJECT) {
			if(isParameterized && !isParam) {
				importClassSet.add("io.vertx.core.json.JsonObject");
			}
		} else if(typeKind == CLASS_JSON_ARRAY) {
			if(isParameterized) {
 				importClassSet.add("io.vertx.core.json.JsonArray");
			}
		} else if(!typeKind.basic
				&& !typeKind.collection
				&& typeKind != CLASS_THROWABLE
				&& typeKind != CLASS_OBJECT
				&& typeKind != CLASS_HANDLER
				&& typeKind != CLASS_ASYNC_RESULT
				&& typeKind != CLASS_CLASS_TYPE
				&& typeKind != CLASS_FUNCTION
				&& typeKind != CLASS_VOID
				&& typeInfo.raw != null){
			if(isParam || isParameterized) {
				importClassSet.add(typeInfo.raw.packageName + "." + typeInfo.raw.simpleName);
			}
		}
		if(isParameterized) {
			if(typeKind.basic || typeKind.json || typeKind == CLASS_VOID || typeKind == CLASS_THROWABLE || typeKind == CLASS_CLASS_TYPE || typeInfo.isVariable) {
				importClassSet.add("io.vertx.lang.jphp.converter.TypeConverter");
			} else if(typeKind == CLASS_ENUM) {
				importClassSet.add("io.vertx.lang.jphp.converter.EnumConverter");
			} else if(typeKind == CLASS_DATA_OBJECT){
				importClassSet.add("io.vertx.lang.jphp.converter.DataObjectConverter");
			} else if(typeKind.collection) {
				importClassSet.add("io.vertx.lang.jphp.converter.ContainerConverter");
			} else if(typeKind == CLASS_API) {
				importClassSet.add("io.vertx.lang.jphp.converter.VertxGenVariable0Converter");
			}
		}
		if(typeKind != CLASS_CLASS_TYPE && typeInfo.isParameterized) {
			foreach(arg : typeInfo.args) {
				addImport(arg, true, isParam);
			}
		}
	}
	if(type.isHandler) {
		importClassSet.add("io.vertx.lang.jphp.Handler");
		importClassSet.add("io.vertx.lang.jphp.converter.TypeConverter");
		addImport(type.handlerArg, true, true);
	}
	var noConverter = true;
	var cacheMap = false;
	foreach(methodName:methodsByName.keySet()) {
		var methods = methodsByName[methodName];
		foreach(m : methods){
			if(noConverter && (m.returnType.name != "void" || m.params.size() > 0)) {
				noConverter = false;
			}
			foreach(param : m.params) {
				addImport(param.type, false, true);
			}
			addImport(m.returnType, false, false);
			if(m.cacheReturn) {
				cacheMap = true;
			}
		}
	}
	if(cacheMap) {
		importClassSet.add("java.util.HashMap");
		importClassSet.add("java.util.Map");
	}
	if(!noConverter) {
		importClassSet.add("php.runtime.Memory");
		importClassSet.add("io.vertx.lang.jphp.Utils");
	}

	importClassSet.add("io.vertx.lang.jphp.wrapper.VertxGenVariable" + typeParams.size() + "Wrapper");

	def getConverterMethodName(methodPrefix, paramName){
		return methodPrefix + ifaceSimpleName + "Variable" + paramName + "Converter";
	}
	def getConverterFieldName(paramName){
		return CASE_CAMEL.to(CASE_LOWER_CAMEL, ifaceSimpleName) + "Variable" + paramName + "Converter";
	}
}
package @{packageName};\n

@foreach{importClass:importClassSet}
	import @{importClass};\n
@end{}

@declare{'typeParamInfo'}
	@if{typeParams.size() > 0}
		<
	@end{}
	@code{
		var first = true;
	}
	@foreach{typeParam:typeParams}
		@if{!first}
			,
 		@else{}
			@code{
				first = false;
			}
		@end{}
		@{typeParam.name}
	@end{}
	@if{typeParams.size() > 0}
		>
	@end{}
@end{}

@declare{'methodTemplate'}
	@code{
		var prevParamSize = -1;
		var _else = false;
		var methodIndex = 0;
	}
	@foreach{method:methods}
		@code{
			var params = method.params;
			var paramSize = params.size;
			methodIndex = methodIndex + 1;
		}
		@if{methodName == "toString" && paramSize == 0}
			\n
		    @Signature\n
		    public String toString(){\n
		        return this.getWrappedObject().toString();
		    }\n
		@else{methodName != "toString" || paramSize > 0}
			@if{paramSize != prevParamSize}
				@if{prevParamSize != -1}
					@if{!prevParamEmpty}
				        }/*3*/@includeNamed{'elseThrow'}\n
					@end{}
				    }/*4*/\n
				@end{}
				@code{
					prevParamSize = paramSize;
					_else = false;
					var i = 0;
					prevParamEmpty = paramSize == 0;
				}
				\n
			    @Signature\n
			    public
				@if{method.isStaticMethod}
 					static
				@end{}
 				@{returnInfo}
 				@{methodName}(Environment __ENV__
				@foreach{param:params}
					, Memory arg@{i}
					@code{i = i + 1;}
				@end{}
				) {\n
			@end{}
			@if{paramSize == prevParamSize}
				@if{paramSize == 0}
			        @{convReturnStart}@{convReturnEnd};\n
				@else{}
			        @if{_else}
						} else
 					@else{}
						@code{
							_else = true;
						}
					@end{}
					if(
					@code{
						var first = true;
						var j = 0;
					}
					@foreach{param : params}
						@if{!first}
 							&&
 						@else{}
							@code{
								first = false;
							}
						@end{}
						@if{!param.isNullable}
							Utils.isNotNull(arg@{j}) &&
 						@end{}
						@includeNamed{'checkType'}
						@code{
							j = j + 1;
						}
					@end{}
					) {\n
			            @{convReturnStart}
						@code{
							var k = -1;
						}
						@foreach{param:params}
							@if{k > -1}
								,
 							@else{}
								@code{
									k = k + 1;
								}
							@end{}
							@includeNamed{'convParamType'}
						@end{}
						@{convReturnEnd};\n
				@end{}
			@end{}
			@if{isFluentReturn}
				@if{paramSize > 0}    @end{}
		        return toMemory();\n
			@end{}
			@if{methodIndex == (methods.size())}
				@if{paramSize > 0}
			        }/*2*/@includeNamed{'elseThrow'}\n
				@end{}
			    }/*1*/\n
			@end{}
		@end{}
	@end{}
@end{}

@declare{'checkType'}
	@code{
		var paramType = param.type;
		var paramTypeKind = paramType.kind;
	}
	@if{paramType.isVariable && paramType.param.isClass}
		@{getConverterMethodName("get", paramType.name)}().accept(__ENV__,
 	@else{}
		Utils.
		@if{paramTypeKind == CLASS_STRING}
			isString(__ENV__,
 		@else{paramTypeKind == CLASS_BOXED_PRIMITIVE || paramTypeKind == CLASS_PRIMITIVE}
			is@if{paramTypeKind == CLASS_PRIMITIVE}@{paramType.boxed.simpleName}@else{}@{paramType.simpleName}@end{}(__ENV__,
 		@else{paramTypeKind == CLASS_JSON_OBJECT}
			isJsonObject(__ENV__,
 		@else{paramTypeKind == CLASS_JSON_ARRAY}
			isJsonArray(__ENV__,
 		@else{paramTypeKind == CLASS_DATA_OBJECT}
			isDataObject(__ENV__, @{paramType.name}.class, @{paramType.name}::new, @{paramType.simpleName}::new,
 		@else{paramTypeKind == CLASS_ENUM}
			isEnum(__ENV__, @{paramType.raw.simpleName}.class,
 		@else{paramTypeKind == CLASS_THROWABLE}
			isThrowable(__ENV__,
 		@else{paramType.isVariable}
			isVariable(__ENV__,
 		@else{paramTypeKind == CLASS_VOID}
			isVoid(__ENV__,
 		@else{paramTypeKind == CLASS_OBJECT}
			isObject(__ENV__,
 		@else{paramTypeKind == CLASS_LIST || paramTypeKind == CLASS_SET}
			is@{paramType.raw.simpleName}(__ENV__, @{getTypeConverter(paramType.args.get(0))},
 		@else{paramTypeKind == CLASS_MAP}
			isMap(__ENV__, @{getTypeConverter(paramType.args.get(1))},
 		@else{paramTypeKind == CLASS_API}
			isVertxGen(@{paramType.raw.packageName}.@{paramType.raw.simpleName}.class, @{paramType.raw.simpleName}.class,
 		@else{paramTypeKind == CLASS_HANDLER}
 			@code{
 				var handlerType = paramType.args.get(0);
 			}
 			@if{handlerType.kind == CLASS_ASYNC_RESULT}
				isHandlerAsyncResult(__ENV__,
 			@else{}
				isHandler(__ENV__,
 			@end{}
 		@else{paramTypeKind == CLASS_FUNCTION}
			isFunction(__ENV__,
 		@else{paramTypeKind == CLASS_ASYNC_RESULT}
			isAsyncResult(__ENV__,
 		@else{paramTypeKind == CLASS_CLASS_TYPE}
			isClassType(__ENV__,
 		@else{}
			isUnknown(__ENV__,
 		@end{}
	@end{}
	arg@{j})
@end{}
@declare{'convParamType'}
	@code{
		var paramType = param.type;
		var paramTypeKind = paramType.kind;
	}
	@if{paramType.isVariable && paramType.param.isClass}
		@{getConverterMethodName("get", paramType.name)}().convParam(__ENV__,
 	@else{}
		Utils.
		@if{paramTypeKind == CLASS_STRING}
			convParamString(__ENV__,
 		@else{paramTypeKind == CLASS_BOXED_PRIMITIVE || paramTypeKind == CLASS_PRIMITIVE}
			convParam@if{paramTypeKind == CLASS_PRIMITIVE}@{paramType.boxed.simpleName}@else{}@{paramType.simpleName}@end{}(__ENV__,
 		@else{paramTypeKind == CLASS_JSON_OBJECT}
			convParamJsonObject(__ENV__,
 		@else{paramTypeKind == CLASS_JSON_ARRAY}
			convParamJsonArray(__ENV__,
 		@else{paramTypeKind == CLASS_DATA_OBJECT}
			convParamDataObject(__ENV__, @{paramType.name}.class, @{paramType.name}::new, @{paramType.simpleName}::new,
 		@else{paramTypeKind == CLASS_ENUM}
			convParamEnum(__ENV__, @{paramType.raw.simpleName}.class,
 		@else{paramTypeKind == CLASS_THROWABLE}
			convParamThrowable(__ENV__,
 		@else{paramType.isVariable}
			convParamVariable(__ENV__,
 		@else{paramTypeKind == CLASS_OBJECT}
			convParamObject(__ENV__,
 		@else{paramTypeKind == CLASS_API}
 			@code{
 				var typeParamInfo = "";
 				if(paramType.isParameterized) {
 					var first = true;
 					foreach(arg : paramType.args) {
 						if(!first) {
 							typeParamInfo += ", ";
 						} else {
 							first = false;
 						}
 						var argKind = arg.kind;
 						if(arg.isVariable) {
 							if(arg.param.isClass){
 								typeParamInfo += arg.name;
 							} else {
 								typeParamInfo += "Object";
 							}
 						} else {
 							if(argKind == CLASS_API || argKind == CLASS_DATA_OBJECT) {
 								typeParamInfo += arg.raw.packageName + "." + arg.raw.simpleName;
 							} else {
 								typeParamInfo += arg.raw.simpleName;
 							}
 						}
 					}
 				}
				var typeParamInfo2 = typeParamInfo == "" ? "" : "<" + typeParamInfo + ">";
 			}
 			<@{paramType.raw.packageName}.@{paramType.raw.simpleName}@{typeParamInfo2}, @{paramType.raw.simpleName}@{typeParamInfo2}
 			@if{typeParamInfo != ""}
 				, @{typeParamInfo}
 			@end{}
 			>
			convParamVertxGenVariable
			@if{paramType.isParameterized}
				@{paramType.args.size()}(__ENV__, @{paramType.raw.simpleName}.class, @{paramType.raw.simpleName}::__create,
  				@foreach{arg : paramType.args}
					@{getTypeConverter(arg)},
 				@end{}
			@else{}
				0(__ENV__, @{paramType.raw.simpleName}.class, @{paramType.raw.simpleName}::__create,
 			@end{}
		@else{paramTypeKind == CLASS_LIST || paramTypeKind == CLASS_SET}
			convParam@{paramType.raw.simpleName}(__ENV__, @{getTypeConverter(paramType.args.get(0))},
 		@else{paramTypeKind == CLASS_MAP}
			convParamMap(__ENV__, @{getTypeConverter(paramType.args.get(1))},
 		@else{paramTypeKind == CLASS_CLASS_TYPE}
			convParamClassType(__ENV__,
 		@else{paramTypeKind == CLASS_HANDLER}
			@code{
				var handlerType = paramType.args.get(0);
				var handlerTypeKind = handlerType.kind;
			}
			@if{handlerTypeKind == CLASS_ASYNC_RESULT}
				@code{
					var asyncResultType = handlerType.args.get(0);
				}
				convParamHandlerAsyncResult(__ENV__, @{getTypeConverter(asyncResultType)},
			@else{}
				convParamHandler(__ENV__, @{getTypeConverter(handlerType)},
			@end{}
 		@else{paramTypeKind == CLASS_FUNCTION}
			@code{
				var args = paramType.args;
				var firstType = args.get(0);
				var secondType = args.get(1);
			}
			convParamFunction(__ENV__, @{getTypeConverter(firstType)}, @{getTypeConverter(secondType)},
 		@else{}
			convParamUnknownType@{paramType.raw.simpleName}(
		@end{}
	@end{}
	arg@{k})
	@code{
		k += 1;
	}
@end{}

@declare{'elseThrow'}
 		else {\n
            throw new RuntimeException("function invoked with invalid arguments");\n
        }
@end{}


@Name("@{ifaceSimpleName}")\n
@Namespace("@{packageName.replace(".", "\\\\")}")\n
@SuppressWarnings("ALL")\n
@if{deprecated}
	@Deprecated\n
@end{}
public class @{ifaceSimpleName}
	@includeNamed{'typeParamInfo';front=true;back=true}
 	extends VertxGenVariable@{typeParams.size()}Wrapper<@{ifaceFQCN}
	@foreach{typeParam:typeParams}
,		@{typeParam.name}
	@end{}
	>
	@if{type.isHandler}
		implements Handler<@{type.handlerArg.name}>
	@end{}
	{\n
	@if{cacheMap}
	    private Map<String, Memory> cacheMap = new HashMap<>();
	@end{}
    \n
    private @{ifaceSimpleName}(Environment env, @{ifaceFQCN} wrappedObject
		@foreach{typeParam : typeParams}
			, TypeConverter<@{typeParam.name}> @{getConverterFieldName(typeParam.name)}
		@end{}
	){\n
        super(env, wrappedObject
			@foreach{typeParam : typeParams}
				, @{getConverterFieldName(typeParam.name)}
			@end{}
		);\n
    }\n
    public static @includeNamed{'typeParamInfo';front=true;back=true} @{ifaceSimpleName}@includeNamed{'typeParamInfo';front=true;back=true} __create(Environment env, @{ifaceFQCN} wrappedObject
		@foreach{typeParam : typeParams}
			, TypeConverter<@{typeParam.name}> @{getConverterFieldName(typeParam.name)}
		@end{}
	){\n
        return new @{ifaceSimpleName}
		@if{typeParams.size() > 0}
			<>
		@end{}
		(env, wrappedObject
			@foreach{typeParam : typeParams}
				, @{getConverterFieldName(typeParam.name)}
			@end{}
		);\n
    }\n
	@if{typeParams.size() > 0}
		@code{
			var typeParamInfo = "<";
			var first = true;
			for(typeParam : typeParams) {
				if(!first) {
					typeParamInfo += ", ";
				} else {
					first = false;
				}
				typeParamInfo += "Object";
			}
			typeParamInfo += ">";
		}
		\n
	    public static @{ifaceSimpleName}@{typeParamInfo} __create(Environment env, @{ifacePackageName}.@{ifaceSimpleName}@{typeParamInfo} wrappedObject) {\n
	        return new @{ifaceSimpleName}<>(env, wrappedObject
			@foreach{typeParam : typeParams}
				, TypeConverter.UNKNOWN_TYPE
			@end{}
			);\n
	    }\n
	@end{}
	@code{
		var i = 1;
	}
	@foreach{typeParam : typeParams}
		@code{
			var fieldName = getConverterFieldName(typeParam.name);
		}
		\n
	    public TypeConverter<@{typeParam.name}> @{getConverterMethodName("get", typeParam.name)}() {\n
	        return this.getTypeConverter@{i}();\n
	    }\n
		\n
	    public void @{getConverterMethodName("set", typeParam.name)}(TypeConverter<@{typeParam.name}> @{fieldName}) {\n
	        this.setTypeConverter@{i}(@{fieldName});\n
	    }\n
		@code{
			i += 1;
		}
	@end{}
	@if{type.isHandler}
	    public TypeConverter<@{type.handlerArg.name}> get__handlerConverter__(){\n
	        return @{getTypeConverter(type.handlerArg)};\n
	    }\n
	@end{}
	@code{
		var prevParamEmpty = true;
	}
	@foreach{methodName:methodsByName.keySet()}
		@code{
			var methods = methodsByName[methodName];
			var minParamSize = 99;
			var maxParamSize = 0;
			var method = methods.get(0);
			var isFluentReturn = method.isFluent;
			var returnType = method.returnType;
			var returnInfo = returnType.name == "void" ? "void" : "Memory";
			var returnTypeKind = returnType.kind;
			var convInfo = null;
			var invokerObj = "Utils";
			if(returnTypeKind == CLASS_STRING) {
				convInfo = ["convReturnString", ""];
			} else if(returnTypeKind == CLASS_BOXED_PRIMITIVE || returnTypeKind == CLASS_PRIMITIVE){
				convInfo = ["convReturn" + (returnTypeKind == CLASS_PRIMITIVE ? returnType.boxed.simpleName : returnType.simpleName), ""];
			} else if(returnTypeKind == CLASS_ENUM){
				convInfo = ["convReturnEnum", ""];
			} else if(returnTypeKind == CLASS_JSON_OBJECT){
				convInfo = ["convReturnJsonObject", ""];
			} else if(returnTypeKind == CLASS_JSON_ARRAY){
				convInfo = ["convReturnJsonArray", ""];
			} else if(returnTypeKind == CLASS_THROWABLE){
				convInfo = ["convReturnThrowable", ""];
			} else if(returnTypeKind == CLASS_VOID){
				convInfo = ["convReturnVoid", ""];
			} else if(returnType.isVariable){
				if(returnType.param.isClass) {
					invokerObj = getConverterMethodName("get", returnType.name) + "()";
					convInfo = ["convReturn", ""];
				} else {
					convInfo = ["convReturnVariable", ""];
				}
			} else if(returnTypeKind == CLASS_OBJECT){
				convInfo = ["convReturnObject", ""];
			} else if(returnTypeKind == CLASS_LIST || returnTypeKind == CLASS_SET){
				convInfo = ["convReturn" + returnType.raw.simpleName, getTypeConverter(returnType.args.get(0)) + ","];
			} else if(returnTypeKind == CLASS_MAP){
				convInfo = ["convReturnMap", getTypeConverter(returnType.args.get(1)) + ","];
			} else if(returnTypeKind == CLASS_API){
				var typeParamSize = 0;
				var typeConverter = "";
				if(returnType.isParameterized) {
					var args = returnType.args;
					typeParamSize = args.size();
					foreach(arg : args) {
						typeConverter += ", " + getTypeConverter(arg);
					}
				}
				var typeParamInfo = "";
				if(returnType.isParameterized) {
					var first = true;
					foreach(arg : returnType.args) {
						if(!first) {
							typeParamInfo += ", ";
						} else {
							first = false;
						}
						if(arg.isVariable) {
							if(arg.param.isClass) {
								typeParamInfo += arg.name;
							} else {
								typeParamInfo += "Object";
							}
						} else {
							var argKind = arg.kind;
							if(argKind == CLASS_API || argKind == CLASS_DATA_OBJECT) {
								typeParamInfo += arg.raw.packageName + "." + arg.raw.simpleName;
							} else {
								typeParamInfo += arg.raw.simpleName;
							}
						}
					}
				}
				var typeParamInfo2 = typeParamInfo == "" ? "" : "<" + typeParamInfo + ">";
				convInfo = ["<" + returnType.raw.packageName + "." + returnType.raw.simpleName + typeParamInfo2 + ", " + returnType.raw.simpleName + typeParamInfo2 + (typeParamInfo == "" ? "" : ", ") + typeParamInfo + ">" + "convReturnVertxGenVariable" + typeParamSize, returnType.raw.simpleName + ".class, " + returnType.raw.simpleName + "::__create" + typeConverter + ", "];
			} else if(returnTypeKind == CLASS_DATA_OBJECT){
				convInfo = ["convReturnDataObject", returnType.name + ".class, " + returnType.raw.simpleName + "::new, " + returnType.raw.name + "::new, "];
			} else if(returnTypeKind == CLASS_HANDLER){
				var handlerType = returnType.args.get(0);
				if(handlerType.kind == CLASS_ASYNC_RESULT) {
					convInfo = ["convReturnHandlerAsyncResult", getTypeConverter(handlerType.args.get(0)) + ","];
				} else {
					convInfo = ["convReturnHandler", getTypeConverter(handlerType) + ","];
				}
			} else if(returnTypeKind == CLASS_FUNCTION){
				convInfo = ["convReturnFunction", getTypeConverter(returnType.args.get(0)) + "," + getTypeConverter(returnType.args.get(1)) + ","];
			} else if(returnTypeKind == CLASS_ASYNC_RESULT){
				convInfo = ["convReturnAsyncResult", ""];
			} else if(returnTypeKind == CLASS_CLASS_TYPE){
				convInfo = ["convReturnClassType", ""];
			} else if(returnTypeKind == CLASS_OTHER){
				convInfo = ["convReturnOther", ""];
			} else {
				convInfo = ["convReturnUnknown", ""];
			}
			var convReturnStart = "";
			var convReturnEnd = "";
			if(returnInfo != "void" && !method.isFluent) {
				convReturnStart += "return ";
				if(method.cacheReturn) {
					convReturnStart += "cacheMap.computeIfAbsent(\"" + method.name + "\", key -> ";
					convReturnEnd = ")" + convReturnEnd;
				}
				convReturnStart += invokerObj + "." + convInfo.get(0) + "(__ENV__, " + convInfo.get(1);
				convReturnEnd = ")" + convReturnEnd;
			}
			if(method.isStaticMethod) {
				convReturnStart += ifacePackageName + "." + ifaceSimpleName;
			} else {
				convReturnStart += "this.getWrappedObject()";
			}
			convReturnStart += "." + method.name + "(";
			convReturnEnd = ")" + convReturnEnd;
		}
		@includeNamed{'methodTemplate'}
	@end{}
\n
}\n