@code{
    /*
     * @param typeParams List<TypeParamInfo> ClassModel.getTypeParams() or  MethodInfo.getTypeParams()
     * @param tag return T extends Memory if true, and return T if false
     */
    def parseTypeParams(typeParams, tag) {
        if (!typeParams.isEmpty){
            var ret = '';
            for (param:typeParams){
                if (ret != '') {
                    ret += ', ';
                }
                /*ret += param.name + (tag ? " extends Memory" : "");*/
                ret += "Memory";
            }
            return '<' + ret + '>';
        } else {
          return '';
        }
    }
    /*
     * @param typeParams List<TypeInfo> ParameterizedTypeInfo.getArgs()/isParameterized
     * @param tag return T extends Memory if true, and return T if false
     */
    def parseTypeArgs(typeArgs, tag) {
        if (!typeArgs.isEmpty){
            var ret = '';
            for (arg:typeArgs){
                if (ret != '') {
                    ret += ', ';
                }
                ret += wrapTypeSimpleNameWithArg(arg, tag);
            }
            return ret == '' ? '' : ('<' + ret + '>');
        } else {
          return '';
        }
    }

    def wrapTypeSimpleName(typeInfo) {
        return wrapTypeSimpleNameWithArg(typeInfo, true)
    }
    def wrapTypeSimpleNameWithArg(typeInfo, withArg){
        if(typeInfo.kind == CLASS_VOID || typeInfo.name == "void") {
            return "void";
        } else if(typeInfo.kind == CLASS_PRIMITIVE) {
            return typeInfo.name;
        } else if(typeInfo.kind == CLASS_STRING) {
            return "String";
        } else if(typeInfo.kind == CLASS_THROWABLE) {
            return "JavaThrowable";
        } else {
            if(typeInfo.kind == CLASS_API || typeInfo.kind == CLASS_DATA_OBJECT) {
                return typeInfo.raw.simpleName;
            } else {
                var typeParamsStr = (withArg && typeInfo.isParameterized) ? parseTypeArgs(typeInfo.args, withArg) : "";
                return typeInfo.isVariable ? "Memory" : typeInfo.raw.simpleName + typeParamsStr;
                
            }
        }
    }
    def getReturnType(typeInfo, methodInfo){
        return wrapTypeSimpleNameWithArg(methodInfo.isFluent ? typeInfo : methodInfo.returnType, false);
    }
    def translateClassName(classType){
        return classType.raw.translatePackageName("php") + "." + classType.raw.simpleName;
    }
    def translatePHPClassName(classType){
        return classType.raw.translatePackageName("php").replace(".", "\\") + "\\" + classType.simpleName;
    }
    def wrapJavaImport2PhpUse(name){
        return name.replace(".", "\\");
    }
    def getParamType(paramType){
        var paramKind = paramType.kind;
        if(paramKind == CLASS_HANDLER || paramKind == CLASS_FUNCTION) {
            return "Closure";
        } else {
            return wrapTypeSimpleName(param.type);
        }
        
    }
    def getJavaParamInfos(method){
        var paramKey = method.name + "-" + paramSize;;
        var methodParams = paramsMap[paramKey];
        var res = '';
        var memoryIndex = 0;
        foreach(params : methodParams) {
            if(res != ''){
                res += ', ';
            }
            if(params.size() == 1) {
                var param = params.get(0);
                res += getParamType(param.type) + ' ' + param.name;
            } else {
                res += "Memory memory" + memoryIndex;
                memoryIndex += 1;
            }
        }
        return res;
    }

    def getParamWrapper(){

    }
}

@declare{'methodBody'}
@code{
    var returnType = method.returnType;
    var returnTypeKind = returnType.kind;
    var isStatic = method.isStaticMethod;
}
@if{returnTypeKind == CLASS_HANDLER}
return @if{type.simpleName == 'CompositeFuture'}null@else{}new Handler(__env__, @{className}.this::handle)@end{};\n
@else{type.simpleName == 'CompositeFuture' && !returnType.isVariable && returnTypeKind != CLASS_VOID && returnTypeKind != CLASS_PRIMITIVE && returnType.name.startsWith("io.vertx.core.Future")}
return null;\n
@else{}
@if{!method.isFluent && method.returnType.name != "void"}
return 
@if{returnTypeKind == CLASS_DATA_OBJECT || returnTypeKind == CLASS_API}
new @{getReturnType(type, method)}(__env__, 
@else{returnTypeKind == CLASS_THROWABLE}
new JavaThrowable(__env__, 
@else{}

@end{}
@if{isStatic}
@{type.packageName}.@{type.simpleName}
@else{}
this.getWrappedObject()
@end{}
.@{method.name}(@includeNamed{'paramBody';method:method})
@if{returnTypeKind == CLASS_DATA_OBJECT || returnTypeKind == CLASS_API || returnTypeKind == CLASS_THROWABLE}
)
@end{};\n
@end{}
@end{}
@if{method.isFluent} 
return this;\n
@end{}
@end{}



@declare{'paramBody'}
@code{
    var paramKey = method.name + "-" + paramSize;
    var methodParams = paramsMap[paramKey];
    var first = true;
}
@foreach{params : methodParams}
@if{!first}
,
@else{}
@code{first = false}
@end{}
@code{var param = params.get(0);}
@if{params.size() == 1}
@includeNamed{'paramWrapper';param:param}
@else{}
/*paramSize:@{params.size()}*/null
@end{}
@end{}
@end{}





@declare{'paramWrapper'}
@if{param.type.kind == CLASS_API || param.type.kind == CLASS_DATA_OBJECT}
@{param.name}.getWrappedObject()
@else{param.type.kind == CLASS_HANDLER}
e -> {\n
            try{\n
                @{param.name}.__invoke(__env__, null);\n
            } catch (Throwable throwable){\n
                __env__.forwardThrow(throwable);\n
            }\n
        }
@else{param.type.kind == CLASS_FUNCTION}
e -> {\n
            return null;\n
        }
@else{param.type.kind == CLASS_LIST}
@includeNamed{'listMapper';param:param}
@else{}
@{param.name}
@end{}
@end{}



@declare{'listMapper'}
@code{
    var argType = param.type.args[0];
}
@if{argType.kind == CLASS_API || argType.kind == CLASS_DATA_OBJECT}
@{param.name}.stream().map(@{argType.simpleName}::getWrappedObject).collect(Collectors.toList())
@else{}
@{param.name}
@end{}
@end{}