@code{
	import java.util.ArrayList;
	var reline = new Character(10).toString();
	def split(str){
		var newStr = str.trim();
		var array = newStr.split(reline);
		var list = new ArrayList();
		for(var i = 0; i < array.length; i++) {
			list.add(array[i]);
		}
		return list;
	}

	def genPHPDocType(type) {
		if(type.name == "void"){
			return ["void"];
		} else if (type.kind == CLASS_STRING) {
			return ['string'];
		} else if (type.kind == CLASS_PRIMITIVE || type.kind == CLASS_BOXED_PRIMITIVE) {
			if (type.simpleName == 'boolean' || type.simpleName == 'Boolean') {
				return ['bool'];
			} else if (type.simpleName == 'char' || type.simpleName == 'Character') {
				return ['string'];
			} else if (type.simpleName == 'double' || type.simpleName == 'Double' || type.simpleName == 'float' || type.simpleName == 'Float') {
				return ['float'];
			} else {
				return ['integer'];
			}
		} else if (type.kind == CLASS_JSON_OBJECT) {
			return ['array'];
		} else if (type.kind == CLASS_JSON_ARRAY) {
			return ['array'];
		} else if (type.kind == CLASS_DATA_OBJECT) {
			return [type.raw.simpleName, 'mixed'];
		} else if (type.kind == CLASS_ENUM) {
			return ['string'];
		} else if (type.kind == CLASS_API) {
			return type.raw.handler ? [type.raw.simpleName, "callable"] : [type.raw.simpleName];
		} else if (type.kind.collection) {
			return ['array'];
		} else if (type.kind == CLASS_MAP) {
			return ['array'];
		} else if (type.kind == CLASS_OBJECT) {
			return ['mixed'];
		} else if (type.kind == CLASS_HANDLER) {
			return ['callable'];
		} else if (type.kind == CLASS_FUNCTION) {
			return ['callable'];
		} else if (type.kind == CLASS_THROWABLE) {
			return ['\\Exception'];
		} else if (type.kind == CLASS_CLASS_TYPE) {
			return ['string'];
		} else {
			return ['todo' + type.name];
		}
	}
	def join(arr, joiner, start, end){
		var first = true;
		var result = "" + start;
		foreach(value : arr) {
			if(!first) {
				result += " " + joiner + " ";
			} else {
				first = false;
			}
			result += value;
		}
		return result + end;
	}

	def getReturnInfo(propertyType){
		var propertyKind = propertyType.kind;
		if(propertyKind.collection || propertyKind.json) {
			return "[]";
		} else if(propertyKind.basic){
			if(propertyKind == CLASS_STRING) {
				return "\"\"";
			} else if(propertyType.simpleName == "Boolean" || propertyType.simpleName == "boolean") {
				return "false";
			} else {
				return "0";
			}
		}else {
			return null;
		}
	}
	def addImport(typeInfo){
		if(typeInfo.isVariable) {
			return;
		}
		if(type.simpleName == typeInfo.simpleName) {
			return;
		}
		var typeKind = typeInfo.kind;
		if(typeKind == CLASS_API || typeKind == CLASS_DATA_OBJECT) {
			if(typeInfo.raw.packageName != type.raw.packageName) {
				importClassSet.add(typeInfo.raw.translatePackageName("jphp") + "." + typeInfo.raw.simpleName);
			}
		} else if(typeKind == CLASS_ENUM) {
			importClassSet.add(typeInfo.raw.packageName + "." + typeInfo.raw.simpleName);
		} else if(typeKind.json) {
			importClassSet.add(typeInfo.raw.packageName + "." + typeInfo.raw.simpleName);
		}
	}


	import java.util.HashMap;

	var typeConverterMap = new HashMap();
	typeConverterMap["String"] = "STRING";
	typeConverterMap["byte"] = "BYTE";
	typeConverterMap["Byte"] = "BYTE";
	typeConverterMap["char"] = "CHARACTER";
	typeConverterMap["Character"] = "CHARACTER";
	typeConverterMap["short"] = "SHORT";
	typeConverterMap["Short"] = "SHORT";
	typeConverterMap["int"] = "INTEGER";
	typeConverterMap["Integer"] = "INTEGER";
	typeConverterMap["long"] = "LONG";
	typeConverterMap["Long"] = "LONG";
	typeConverterMap["double"] = "DOUBLE";
	typeConverterMap["Double"] = "DOUBLE";
	typeConverterMap["float"] = "FLOAT";
	typeConverterMap["Float"] = "FLOAT";
	typeConverterMap["boolean"] = "BOOLEAN";
	typeConverterMap["Boolean"] = "BOOLEAN";
	typeConverterMap["JsonObject"] = "JSON_OBJECT";
	typeConverterMap["JsonArray"] = "JSON_ARRAY";
	typeConverterMap["Throwable"] = "THROWABLE";
	typeConverterMap["Void"] = "VOID";

	def getTypeConverter(typeInfo){
		var typeKind = typeInfo.kind;
		if(typeKind.basic || typeKind.json || typeKind == CLASS_THROWABLE || typeKind == CLASS_VOID) {
			return "TypeConverter." + typeConverterMap[typeKind == CLASS_PRIMITIVE ? typeInfo.name : typeInfo.raw.simpleName];
		} else if(typeKind == CLASS_ENUM){
			return "EnumConverter.create(" + typeInfo.raw.simpleName + ".class)";
		} else if(typeKind == CLASS_DATA_OBJECT){
			return "DataObjectConverter.create(" + typeInfo.raw.packageName + "." + typeInfo.raw.simpleName + ".class, " + typeInfo.raw.packageName + "." + typeInfo.raw.simpleName + "::new, " + typeInfo.raw.simpleName + "::new)";
		} else if(typeKind == CLASS_LIST || typeKind == CLASS_SET || typeKind == CLASS_MAP) {
			var containerType = null;
			if(typeKind != CLASS_MAP){
				containerType = typeInfo.args.get(0);
			} else {
				containerType = typeInfo.args.get(1);
			}
			return "ContainerConverter.create" + typeInfo.raw.simpleName + "Converter(" + getTypeConverter(containerType) + ")";
		} else if(typeKind == CLASS_API) {
			var args = typeInfo.isParameterized ? typeInfo.args : [];
			var returnInfo = "VertxGenVariable0Converter.<";
			var typeParamInfo = "";
			var first = true;
			foreach(arg : args) {
				if(!first) {
					typeParamInfo += ", ";
				} else {
					first = false;
				}
				if(arg.isVariable) {
					if(arg.param.isClass) {
						typeParamInfo += arg.name;
					} else  {
						typeParamInfo += "Object";
					}
				} else {
					var argKind = arg.kind;
					if(argKind == CLASS_API || argKind == CLASS_DATA_OBJECT) {
						typeParamInfo += arg.raw.packageName + "." + arg.raw.simpleName;
					} else {
						typeParamInfo += arg.raw.simpleName;
					}
				}
			}
			var typeParamInfo2 = (typeParamInfo == "") ? "" : ("<" + typeParamInfo + ">");
			returnInfo += typeInfo.raw.packageName + "." + typeInfo.raw.simpleName + typeParamInfo2 + ", " + typeInfo.raw.simpleName + typeParamInfo2;
			returnInfo += (typeParamInfo == "" ? "" : ", ");
			returnInfo += typeParamInfo;
			returnInfo += ">create" + args.size() + "(" + typeInfo.raw.simpleName + ".class, " + typeInfo.raw.simpleName + "::__create";
			for(arg : args) {
				returnInfo += ", " + getTypeConverter(arg);
			}
			return returnInfo + ")";
		} else if(typeInfo.isVariable && typeInfo.param.isClass){
			return getConverterMethodName("get", typeInfo.name) + "()";
		} else {
			return "TypeConverter.UNKNOWN_TYPE";
		}
	}
}