= Vert.x Web Client
:toc: left
:lang: php
:php: php

Vert.x Web Client is an asynchronous HTTP and HTTP/2 client.

The Web Client makes easy to do HTTP request/response interactions with a web server, and provides advanced
features like:

* Json body encoding / decoding
* request/response pumping
* request parameters
* unified error handling
* form submissions

The web client does not deprecate the Vert.x Core `link:https://vertx.okou.tk/phpdoc/classes/io.vertx.jphp.core.http.HttpClient.html[HttpClient]`, indeed it is based on
this client and inherits its configuration and great features like pooling, HTTP/2 support, pipelining support, etc...
The `link:https://vertx.okou.tk/phpdoc/classes/io.vertx.jphp.core.http.HttpClient.html[HttpClient]` should be used when fine grained control over the HTTP
requests/responses is necessary.

The web client does not provide a WebSocket API, the Vert.x Core `link:https://vertx.okou.tk/phpdoc/classes/io.vertx.jphp.core.http.HttpClient.html[HttpClient]` should
be used. It also does not handle cookies at the moment.

== Using the web client

To use Vert.x Web Client, add the following dependency to the _dependencies_ section of your build descriptor:

* Maven (in your `pom.xml`):

[source,xml,subs="+attributes"]
----
<dependency>
 <groupId>io.vertx</groupId>
 <artifactId>vertx-web-client</artifactId>
 <version>${maven.version}</version>
</dependency>
----

* Gradle (in your `build.gradle` file):

[source,groovy,subs="+attributes"]
----
dependencies {
 compile 'io.vertx:vertx-web-client:${maven.version}'
}
----

== Re-cap on Vert.x core HTTP client

Vert.x Web Client uses the API from Vert.x core, so it's well worth getting familiar with the basic concepts of using
`link:https://vertx.okou.tk/phpdoc/classes/io.vertx.jphp.core.http.HttpClient.html[HttpClient]`using Vert.x core, if you're not already.

== Creating a web client

You create an `link:https://vertx.okou.tk/phpdoc/classes/io.vertx.jphp.ext.web.client.WebClient.html[WebClient]` instance with default options as follows

[source,php]
----
<?php
    use io\vertx\jphp\ext\web\client\WebClient;
    $client = WebClient::create($vertx);

----

If you want to configure options for the client, you create it as follows

[source,php]
----
<?php
    use io\vertx\jphp\ext\web\client\WebClient;
    $options = array(
        "userAgent" => "My-App/1.2.3"
    );
    $options["keepAlive"] = false;
    $client = WebClient::create($vertx, $options);

----

Web Client options inherit Http Client options so you can set any one of them.

If your already have an HTTP Client in your application you can also reuse it

[source,php]
----
<?php
    use io\vertx\jphp\ext\web\client\WebClient;
    $client = WebClient::wrap($httpClient);

----

== Making requests

=== Simple requests with no body

Often, you¡¯ll want to make HTTP requests with no request body. This is usually the case with HTTP GET, OPTIONS
and HEAD requests

[source,php]
----
<?php
    use io\vertx\jphp\ext\web\client\WebClient;

    $client = WebClient::create($vertx);

    // Send a GET request
    $client->get(8080, "myserver.mycompany.com", "/some-uri")->send(function ($ar, $ar_err) {
        if ($ar != null) {
            // Obtain response
            $response = $ar;

            echo "Received response with status code".$response->statusCode()."\n";
        } else {
            echo "Something went wrong ".$ar_err->getMessage()."\n";
        };
    });

    // Send a HEAD request
    $client->head(8080, "myserver.mycompany.com", "/some-uri")->send(function ($ar, $ar_err) {
        if ($ar != null) {
            // Obtain response
            $response = $ar;

            echo "Received response with status code".$response->statusCode()."\n";
        } else {
            echo "Something went wrong ".$ar_err->getMessage()."\n";
        };
    });

----

You can add query parameters to the request URI in a fluent fashion

[source,php]
----
Code not translatable
----

Any request URI parameter will pre-populate the request

[source,php]
----
<?php
    $request = $client->get(8080, "myserver.mycompany.com", "/some-uri?param1=param1_value&param2=param2_value");

    // Add param3
    $request->addQueryParam("param3", "param3_value");

    // Overwrite param2
    $request->setQueryParam("param2", "another_param2_value");

----

Setting a request URI discards existing query parameters

[source,php]
----
<?php
    $request = $client->get(8080, "myserver.mycompany.com", "/some-uri");

    // Add param1
    $request->addQueryParam("param1", "param1_value");

    // Overwrite param1 and add param2
    $request->uri("/some-uri?param1=param1_value&param2=param2_value");

----

=== Writing request bodies

When you need to make a request with a body, you use the same API and call then `sendXXX` methods
that expects a body to send.

Use `link:https://vertx.okou.tk/phpdoc/classes/io.vertx.jphp.ext.web.client.HttpRequest.html#method_sendBuffer[sendBuffer]` to send a buffer body

[source,php]
----
<?php
    // Send a buffer to the server using POST, the content-length header will be set for you
    $client->post(8080, "myserver.mycompany.com", "/some-uri")->sendBuffer($buffer, function ($ar, $ar_err) {
        if ($ar != null) {
            // Ok
        };
    });

----

Sending a single buffer is useful but often you don't want to load fully the content in memory because
it may be too large or you want to handle many concurrent requests and want to use just the minimum
for each request. For this purpose the web client can send `ReadStream<Buffer>` (e.g a
`link:https://vertx.okou.tk/phpdoc/classes/io.vertx.jphp.core.file.AsyncFile.html[AsyncFile]`is a ReadStream<Buffer>`) with the `link:https://vertx.okou.tk/phpdoc/classes/io.vertx.jphp.ext.web.client.HttpRequest.html#method_sendStream[sendStream]` method

[source,php]
----
Code not translatable
----

The web client takes care of setting up the transfer pump for you. Since the length of the stream is not know
the request will use chunked transfer encoding .

When you know the size of the stream, you shall specify before using the `content-length` header

[source,php]
----
<?php
    $fs->open("content.txt", array(
    ), function ($fileRes, $fileRes_err) {
        if ($fileRes != null) {
            $fileStream = $fileRes;

            $fileLen = "1024";

            // Send the file to the server using POST
            $client->post(8080, "myserver.mycompany.com", "/some-uri")->putHeader("content-length", $fileLen)->sendStream($fileStream, function ($ar, $ar_err) {
                if ($ar != null) {
                    // Ok
                };
            });
        };
    });

----

The POST will not be chunked.

==== Json bodies

Often you¡¯ll want to send Json body requests, to send a `JsonObject`
use the `link:https://vertx.okou.tk/phpdoc/classes/io.vertx.jphp.ext.web.client.HttpRequest.html#method_sendJsonObject[sendJsonObject]`

[source,php]
----
<?php
    $client->post(8080, "myserver.mycompany.com", "/some-uri")->sendJsonObject(array(
        "firstName" => "Dale",
        "lastName" => "Cooper"
    ), function ($ar, $ar_err) {
        if ($ar != null) {
            // Ok
        };
    });

----

In Java, Groovy or Kotlin, you can use the `link:https://vertx.okou.tk/phpdoc/classes/io.vertx.jphp.ext.web.client.HttpRequest.html#method_sendJson[sendJson]` method that maps
a POJO (Plain Old Java Object) to a Json object using `link:null#method_encode[Json::encode]`
method

[source,php]
----
<?php
    $client->post(8080, "myserver.mycompany.com", "/some-uri")->sendJson(Java::type("examples.WebClientExamples.User").newInstance("Dale", "Cooper"), function ($ar, $ar_err) {
        if ($ar != null) {
            // Ok
        };
    });

----

NOTE: the `link:null#method_encode[Json::encode]` uses the Jackson mapper to encode the object
to Json.

==== Form submissions

You can send http form submissions bodies with the `link:https://vertx.okou.tk/phpdoc/classes/io.vertx.jphp.ext.web.client.HttpRequest.html#method_sendForm[sendForm]`
variant.

[source,php]
----
<?php
    use io\vertx\jphp\core\MultiMap;
    $form = MultiMap::caseInsensitiveMultiMap();
    $form->set("firstName", "Dale");
    $form->set("lastName", "Cooper");

    // Submit the form as a form URL encoded body
    $client->post(8080, "myserver.mycompany.com", "/some-uri")->sendForm($form, function ($ar, $ar_err) {
        if ($ar != null) {
            // Ok
        };
    });

----

By default the form is submitted with the `application/x-www-form-urlencoded` content type header. You can set
the `content-type` header to `multipart/form-data` instead

[source,php]
----
<?php
    use io\vertx\jphp\core\MultiMap;
    $form = MultiMap::caseInsensitiveMultiMap();
    $form->set("firstName", "Dale");
    $form->set("lastName", "Cooper");

    // Submit the form as a multipart form body
    $client->post(8080, "myserver.mycompany.com", "/some-uri")->putHeader("content-type", "multipart/form-data")->sendForm($form, function ($ar, $ar_err) {
        if ($ar != null) {
            // Ok
        };
    });

----

If you want to upload files and send attributes, you can create a `link:https://vertx.okou.tk/phpdoc/classes/io.vertx.jphp.ext.web.multipart.MultipartForm.html[MultipartForm]` and
use `link:https://vertx.okou.tk/phpdoc/classes/io.vertx.jphp.ext.web.client.HttpRequest.html#method_sendMultipartForm[sendMultipartForm]`.

[source,php]
----
<?php
    use io\vertx\jphp\ext\web\multipart\MultipartForm;
    $form = MultipartForm::create()->attribute("imageDescription", "a very nice image")->binaryFileUpload("imageFile", "image.jpg", "/path/to/image", "image/jpeg");

    // Submit the form as a multipart form body
    $client->post(8080, "myserver.mycompany.com", "/some-uri")->sendMultipartForm($form, function ($ar, $ar_err) {
        if ($ar != null) {
            // Ok
        };
    });

----

=== Writing request headers

You can write headers to a request using the headers multi-map as follows:

[source,php]
----
<?php
    $request = $client->get(8080, "myserver.mycompany.com", "/some-uri");
    $headers = $request->headers();
    $headers->set("content-type", "application/json");
    $headers->set("other-header", "foo");

----

The headers are an instance of `link:https://vertx.okou.tk/phpdoc/classes/io.vertx.jphp.core.MultiMap.html[MultiMap]` which provides operations for adding,
setting and removing entries. Http headers allow more than one value for a specific key.

You can also write headers using putHeader

[source,php]
----
<?php
    $request = $client->get(8080, "myserver.mycompany.com", "/some-uri");
    $request->putHeader("content-type", "application/json");
    $request->putHeader("other-header", "foo");

----

=== Reusing requests

The `link:https://vertx.okou.tk/phpdoc/classes/io.vertx.jphp.ext.web.client.HttpRequest.html#method_send[send]` method can be called multiple times
safely, making it very easy to configure and reuse `link:https://vertx.okou.tk/phpdoc/classes/io.vertx.jphp.ext.web.client.HttpRequest.html[HttpRequest]` objects

[source,php]
----
<?php
    $get = $client->get(8080, "myserver.mycompany.com", "/some-uri");
    $get->send(function ($ar, $ar_err) {
        if ($ar != null) {
            // Ok
        };
    });

    // Same request again
    $get->send(function ($ar, $ar_err) {
        if ($ar != null) {
            // Ok
        };
    });

----

Beware though that `link:https://vertx.okou.tk/phpdoc/classes/io.vertx.jphp.ext.web.client.HttpRequest.html[HttpRequest]` instances are mutable.
Therefore you should call the `link:https://vertx.okou.tk/phpdoc/classes/io.vertx.jphp.ext.web.client.HttpRequest.html#method_copy[copy]` method before modifying a cached instance.

[source,php]
----
<?php
    $get = $client->get(8080, "myserver.mycompany.com", "/some-uri");
    $get->send(function ($ar, $ar_err) {
        if ($ar != null) {
            // Ok
        };
    });

    // The "get" request instance remains unmodified
    $get->copy()->putHeader("a-header", "with-some-value")->send(function ($ar, $ar_err) {
        if ($ar != null) {
            // Ok
        };
    });

----

=== Timeouts

You can set a timeout for a specific http request using `link:https://vertx.okou.tk/phpdoc/classes/io.vertx.jphp.ext.web.client.HttpRequest.html#method_timeout[timeout]`.

[source,php]
----
<?php
    $client->get(8080, "myserver.mycompany.com", "/some-uri")->timeout(5000)->send(function ($ar, $ar_err) {
        if ($ar != null) {
            // Ok
        } else {
            // Might be a timeout when cause is java.util.concurrent.TimeoutException
        };
    });

----

If the request does not return any data within the timeout period an exception will be passed to the response
handler.

== Handling http responses

When the web client sends a request you always deal with a single async result `link:https://vertx.okou.tk/phpdoc/classes/io.vertx.jphp.ext.web.client.HttpResponse.html[HttpResponse]`.

On a success result the callback happens after the response has been received

[source,php]
----
<?php
    $client->get(8080, "myserver.mycompany.com", "/some-uri")->send(function ($ar, $ar_err) {
        if ($ar != null) {

            $response = $ar;

            echo "Received response with status code".$response->statusCode()."\n";
        } else {
            echo "Something went wrong ".$ar_err->getMessage()."\n";
        };
    });

----

WARNING: responses are fully buffered, use `link:https://vertx.okou.tk/phpdoc/classes/io.vertx.jphp.ext.web.codec.BodyCodec.html#method_pipe[BodyCodec::pipe]`
to pipe the response to a write stream

=== Decoding responses

By default the web client provides an http response body as a {@code Buffer} and does not apply
any decoding.

Custom response body decoding can be achieved using `link:https://vertx.okou.tk/phpdoc/classes/io.vertx.jphp.ext.web.codec.BodyCodec.html[BodyCodec]`:

* Plain String
* Json object
* Json mapped POJO
* `link:https://vertx.okou.tk/phpdoc/classes/io.vertx.jphp.core.streams.WriteStream.html[WriteStream]`

A body codec can decode an arbitrary binary data stream into a specific object instance, saving you the decoding
step in your response handlers.

Use `link:https://vertx.okou.tk/phpdoc/classes/io.vertx.jphp.ext.web.codec.BodyCodec.html#method_jsonObject[BodyCodec::jsonObject]` To decode a Json object:

[source,php]
----
<?php
    use io\vertx\jphp\ext\web\codec\BodyCodec;
    $client->get(8080, "myserver.mycompany.com", "/some-uri")->as(BodyCodec::jsonObject())->send(function ($ar, $ar_err) {
        if ($ar != null) {
            $response = $ar;

            $body = $response->body();

            echo "Received response with status code".$response->statusCode()." with body ".$body."\n";
        } else {
            echo "Something went wrong ".$ar_err->getMessage()."\n";
        };
    });

----

In Java, Groovy or Kotlin, custom Json mapped POJO can be decoded

[source,php]
----
<?php
    use io\vertx\jphp\ext\web\codec\BodyCodec;
    $client->get(8080, "myserver.mycompany.com", "/some-uri")->as(BodyCodec::json(Java::type("examples.WebClientExamples.User")->class))->send(function ($ar, $ar_err) {
        if ($ar != null) {
            $response = $ar;

            $user = $response->body();

            echo "Received response with status code".$response->statusCode()." with body ".$user->getFirstName()." ".$user->getLastName()."\n";
        } else {
            echo "Something went wrong ".$ar_err->getMessage()."\n";
        };
    });

----

When large response are expected, use the `link:https://vertx.okou.tk/phpdoc/classes/io.vertx.jphp.ext.web.codec.BodyCodec.html#method_pipe[BodyCodec::pipe]`.
This body codec pumps the response body buffers to a `link:https://vertx.okou.tk/phpdoc/classes/io.vertx.jphp.core.streams.WriteStream.html[WriteStream]`
and signals the success or the failure of the operation in the async result response

[source,php]
----
<?php
    use io\vertx\jphp\ext\web\codec\BodyCodec;
    $client->get(8080, "myserver.mycompany.com", "/some-uri")->as(BodyCodec::pipe($writeStream))->send(function ($ar, $ar_err) {
        if ($ar != null) {

            $response = $ar;

            echo "Received response with status code".$response->statusCode()."\n";
        } else {
            echo "Something went wrong ".$ar_err->getMessage()."\n";
        };
    });

----

Finally if you are not interested at all by the response content, the `link:https://vertx.okou.tk/phpdoc/classes/io.vertx.jphp.ext.web.codec.BodyCodec.html#method_none[BodyCodec::none]`
simply discards the entire response body

[source,php]
----
<?php
    use io\vertx\jphp\ext\web\codec\BodyCodec;
    $client->get(8080, "myserver.mycompany.com", "/some-uri")->as(BodyCodec::none())->send(function ($ar, $ar_err) {
        if ($ar != null) {

            $response = $ar;

            echo "Received response with status code".$response->statusCode()."\n";
        } else {
            echo "Something went wrong ".$ar_err->getMessage()."\n";
        };
    });

----

When you don't know in advance the content type of the http response, you can still use the {@code bodyAsXXX()} methods
that decode the response to a specific type

[source,php]
----
<?php
    $client->get(8080, "myserver.mycompany.com", "/some-uri")->send(function ($ar, $ar_err) {
        if ($ar != null) {

            $response = $ar;

            // Decode the body as a json object
            $body = $response->bodyAsJsonObject();

            echo "Received response with status code".$response->statusCode()." with body ".$body."\n";
        } else {
            echo "Something went wrong ".$ar_err->getMessage()."\n";
        };
    });

----

WARNING: this is only valid for the response decoded as a buffer.

=== Handling 30x redirections

By default the client follows redirections, you can configure the default behavior in the `link:../enums.adoc#WebClientOptions[WebClientOptions]`:

[source,php]
----
<?php
    use io\vertx\jphp\ext\web\client\WebClient;

    // Change the default behavior to not follow redirects
    $client = WebClient::create($vertx, array(
        "followRedirects" => false
    ));

----

The client will follow at most `16` requests redirections, it can be changed in the same options:

[source,php]
----
<?php
    use io\vertx\jphp\ext\web\client\WebClient;

    // Follow at most 5 redirections
    $client = WebClient::create($vertx, array(
        "maxRedirects" => 5
    ));

----

== Using HTTPS

Vert.x web client can be configured to use HTTPS in exactly the same way as the Vert.x `link:https://vertx.okou.tk/phpdoc/classes/io.vertx.jphp.core.http.HttpClient.html[HttpClient]`.

You can specify the behavior per request

[source,php]
----
<?php

    $client->get(443, "myserver.mycompany.com", "/some-uri")->ssl(true)->send(function ($ar, $ar_err) {
        if ($ar != null) {
            // Obtain response
            $response = $ar;

            echo "Received response with status code".$response->statusCode()."\n";
        } else {
            echo "Something went wrong ".$ar_err->getMessage()."\n";
        };
    });

----

Or using create methods with absolute URI argument

[source,php]
----
<?php

    $client->getAbs("https://myserver.mycompany.com:4043/some-uri")->send(function ($ar, $ar_err) {
        if ($ar != null) {
            // Obtain response
            $response = $ar;

            echo "Received response with status code".$response->statusCode()."\n";
        } else {
            echo "Something went wrong ".$ar_err->getMessage()."\n";
        };
    });

----

ifdef::java[]
include::override/rxjava.adoc[]
endif::[]